#!/usr/bin/env zsh

DIRECTORY="$HOME/prompts"
PROMPT='Use the prompt from attached file'
DRY_RUN=false
DIRECT_PROMPT=""
typeset -A CUSTOM_ARGS

while [[ $# -gt 0 ]]; do
    case $1 in
        --dir|--directory)
            DIRECTORY="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --select)
            DIRECT_PROMPT="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [PROMPT_NAME] [OPTIONS]"
            echo ""
            echo "Arguments:"
            echo "  PROMPT_NAME               Directly run a prompt by name (without extension)"
            echo ""
            echo "Options:"
            echo "  --select PROMPT_NAME      Directly run a prompt by name (without extension)"
            echo "  --dir, --directory DIR    Directory to search for files (default: \$HOME/prompts)"
            echo "  --dry-run                 Show the command that would be executed without running it"
            echo "  --help, -h                Show this help message"
            echo "  --<key> <value>           Custom arguments to inject into the prompt"
            echo ""
            echo "Examples:"
            echo "  $0                                    # Interactive mode with fzf"
            echo "  $0 my-prompt                          # Run 'my-prompt' directly"
            echo "  $0 --select my-prompt                 # Run 'my-prompt' directly"
            echo "  $0 my-prompt --branch dev             # Run 'my-prompt' with custom variables"
            echo "  $0 --dir /path/to/my/dir --branch dev # Custom directory with variables"
            exit 0
            ;;
        --*)
            # Capture any other --option as a custom argument
            key="${1#--}"
            if [[ $# -lt 2 || "$2" == --* ]]; then
                echo "Error: Option $1 requires a value"
                exit 1
            fi
            CUSTOM_ARGS["$key"]="$2"
            shift 2
            ;;
        *)
            # If no flag, treat as direct prompt name
            if [ -z "$DIRECT_PROMPT" ]; then
                DIRECT_PROMPT="$1"
                shift
            else
                echo "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
            fi
            ;;
    esac
done

# Verify zsh is being used
if [ -z "$ZSH_VERSION" ]; then
    echo "Error: This script requires zsh"
    echo "Please run with: zsh $0 $@"
    echo "Or install zsh:"
    echo "  macOS:         (zsh is pre-installed)"
    echo "  Ubuntu/Debian: sudo apt install zsh"
    echo "  Fedora/RHEL:   sudo dnf install zsh"
    exit 1
fi

if ! command -v fzf &> /dev/null; then
    echo "Error: fzf is not installed. Please install it first."
    exit 1
fi

if ! command -v fd &> /dev/null; then
    echo "Error: fd is not installed. Please install it first."
    exit 1
fi

if [ ! -d "$DIRECTORY" ]; then
    echo "Error: Directory '$DIRECTORY' does not exist."
    exit 1
fi

# Create a mapping between display names and full paths
typeset -A file_map
while IFS= read -r filepath; do
    # Extract filename without extension for display
    display_name=$(basename "$filepath" | sed 's/\.[^.]*$//')
    file_map[$display_name]="$filepath"
done < <(fd --type f . "$DIRECTORY")

# Handle direct prompt selection or interactive mode
if [ -n "$DIRECT_PROMPT" ]; then
    # Direct prompt specified - find and run it
    if [ -z "${file_map[$DIRECT_PROMPT]}" ]; then
        echo "Error: Prompt '$DIRECT_PROMPT' not found in directory '$DIRECTORY'"
        echo ""
        echo "Available prompts:"
        printf '%s\n' "${(k)file_map[@]}" | sort | sed 's/^/  - /'
        exit 1
    fi
    selected_display="$DIRECT_PROMPT"
    selected_file="${file_map[$DIRECT_PROMPT]}"
else
    # Interactive mode - show fzf
    selected_display=$(printf '%s\n' "${(k)file_map[@]}" | sort | fzf \
        --prompt="Select a prompt: " \
        --height=100% \
        --border \
        --preview "cat '${DIRECTORY}/{}.xml' 2>/dev/null || cat '${DIRECTORY}/{}.'* 2>/dev/null" \
        --preview-window=right:60%:wrap)

    if [ -z "$selected_display" ]; then
        echo "Operation cancelled - no prompt selected"
        exit 0
    fi

    selected_file="${file_map[$selected_display]}"
fi

typeset -A required_map

while IFS= read -r line; do
    while [[ $line =~ "\\{\\{([a-zA-Z_][a-zA-Z0-9_]*)\\}\\}" ]]; do
        var="${match[1]}"
        required_map["$var"]=1
        line="${line#*${match}}"
    done
done < "$selected_file"

# Convert keys to array
required_vars=("${(k)required_map[@]}")
# Check for missing variables and prompt interactively
for var in "${required_vars[@]}"; do
    if [ -z "${CUSTOM_ARGS[$var]}" ]; then
        echo -n "Enter value for '$var': " >/dev/tty
        read -r value </dev/tty
        if [ -n "$value" ]; then
            CUSTOM_ARGS["$var"]="$value"
        else
            echo "Warning: No value provided for required variable '$var'" >/dev/tty
        fi
    fi
done

if [ ${#CUSTOM_ARGS[@]} -gt 0 ]; then
    vars_string=""
    for key in "${(k)CUSTOM_ARGS[@]}"; do
        vars_string+="${key}=${CUSTOM_ARGS[$key]}, "
    done
    vars_string="${vars_string%, }"
    PROMPT="${PROMPT}. Variables: ${vars_string}"
fi

COMMAND="opencode run '${PROMPT}' --file \"$selected_file\""

if [ "$DRY_RUN" = true ]; then
    echo "Dry-run mode: Command that would be executed:"
    echo "$COMMAND"
    exit 0
fi

eval "$COMMAND"
